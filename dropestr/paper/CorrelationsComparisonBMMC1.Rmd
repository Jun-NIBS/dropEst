---
title: "Comparison of clusters"
output: 
  html_document:
    df_print: kable
    theme: cerulean
    toc: true
    number_sections: true
  html_notebook: default
---

```{r}
Sys.setenv("plotly_username"="sussahin")
Sys.setenv("plotly_api_key"="YeY67mJWmLpvAbp9yE4N")
```

```{r, include=FALSE}
library(ggplot2)
library(ggsci)
library(ggpubr)
library(ggrastr)
library(dplyr)
library(Matrix)
library(parallel)
library(reshape2)
library(pheatmap)

source("./Functions/Functions.R")
source("./Functions/PlotFuncs.R")
source("./Functions/VariationAnalysisFuncs.R")

knitr::opts_chunk$set(fig.width=5, fig.height=3, echo=FALSE, warning=FALSE, message=FALSE)

theme_set(theme_base)

kPlotDir <- '~/Data/Plots/Paper/Review/UmiErrors/'
kDataPath <- '/d0-mendel/home/viktor_petukhov/Data/10x/frozen_bmmc_healthy_donor1/est_11_10_umi_quality/'
```

```{r}
GetPagoda <- function(cm, n.cores=10, clustering.type='infomap', embeding.type='tSNE', verbose=TRUE) {
  library(pagoda2)
  r <- Pagoda2$new(cm, modelType='plain', trim=5, n.cores=n.cores)
  r$adjustVariance(plot=F, do.par=F, gam.k=10, verbose=verbose)

  r$calculatePcaReduction(nPcs=100, n.odgenes=1000, maxit=1000)
  r$makeKnnGraph(k=30,type='PCA', center=T,distance='cosine',weight.type='none', verbose=verbose)
  if (clustering.type == 'infomap') {
    r$getKnnClusters(method=infomap.community,type='PCA',name='infomap')
  } else if (clustering.type == 'multilevel') {
    r$getKnnClusters(method=multilevel.community,type='PCA',name='multilevel')
  } else stop("Unknown clustering  type")

  if ('largeVis' %in% embeding.type) {
    r$getEmbedding(type='PCA', embeddingType = 'largeVis')
  }
  
  if ('tSNE' %in% embeding.type) {
    r$getEmbedding(type='PCA', perplexity=30, embeddingType = 'tSNE')
  }
  
  return(r)
}
```

```{r}
holder <- readRDS(paste0(kDataPath, 'bmmc.rds'))
if (is.null(holder$reads_per_umi_per_cell$reads_per_umi[[1]][[1]][[2]])) stop("Quality must be provided")

umi_distribution <- GetUmisDistribution(holder$reads_per_umi_per_cell$reads_per_umi)
umi_probs <- umi_distribution / sum(umi_distribution)
collisions_info <- FillCollisionsAdjustmentInfo(umi_probs, max(holder$cm))
length(holder$reads_per_umi_per_cell$reads_per_umi)
```

```{r}
corrected_cms <- list()
max_upg <- sapply(holder$reads_per_umi_per_cell$reads_per_umi, length) %>% max()
max_upg <- collisions_info[max_upg]
correction_info <- PrepareUmiCorrectionInfo(umi_probs, max_upg, verbosity.level=1)

corrected_cms$bayesian <- CorrectUmiSequenceErrors(holder$reads_per_umi_per_cell, method='Bayesian', return='matrix', 
                                                   collisions.info=collisions_info, umi.probabilities=umi_probs, 
                                                   correction.info=correction_info, verbosity.level=2, mc.cores=30)

corrected_cms$simple1 <- CorrectUmiSequenceErrors(holder$reads_per_umi_per_cell, method='Classic', return='matrix',
                                                  collisions.info=collisions_info, umi.probabilities=umi_probs, 
                                                  verbosity.level=2, mc.cores=15)

corrected_cms$simple1.1 <- CorrectUmiSequenceErrors(holder$reads_per_umi_per_cell, method='Classic', return='matrix',
                                                    mult=1+1e-4, collisions.info=collisions_info, umi.probabilities=umi_probs, 
                                                    verbosity.level=2, mc.cores=15)

corrected_cms$simple2 <- CorrectUmiSequenceErrors(holder$reads_per_umi_per_cell, method='Classic', return='matrix',
                                                  mult=2, collisions.info=collisions_info, umi.probabilities=umi_probs, 
                                                  verbosity.level=2, mc.cores=15)

corrected_cms$raw <- holder$cm
corrected_cms$raw@x <- collisions_info[corrected_cms$raw@x]

saveRDS(corrected_cms, paste0(kDataPath, 'cms2.rds'))
```

# Analysis
```{r, message=FALSE, warning=FALSE}
kClusteringType <- 'infomap'
r <- GetPagoda(corrected_cms$raw, n.cores=25, clustering.type=kClusteringType, embeding.type='tSNE', verbose=F)
clusters <- r$clusters$PCA[[kClusteringType]]

r_s1 <- GetPagoda(corrected_cms$simple1, n.cores=25, clustering.type=kClusteringType, embeding.type='tSNE', verbose=F)
# clusters <- r_s1$clusters$PCA[[kClusteringType]]
```

```{r}
kMinCellsPerCluster <- 50
PlotPagodaEmbeding(r_s1, embeding.type='tSNE', clustering.type=kClusteringType, mark.clusters=T, 
                   show.legend=F, min.cluster.size=kMinCellsPerCluster, size=0.5, alpha=0.5, show.ticks=F, plot.na=T) + 
  scale_color_hue(l=55)

PlotPagodaEmbeding(r, embeding.type='tSNE', clustering.type=kClusteringType, mark.clusters=T, 
                   show.legend=F, min.cluster.size=kMinCellsPerCluster, size=0.5, alpha=0.5, show.ticks=F, plot.na=T) + 
  scale_color_hue(l=55)
```

## Full
```{r}
real_clusters <- which(table(clusters) > kMinCellsPerCluster)
```

```{r}
rs <- list()
for (n in names(corrected_cms)) {
  rs[[n]] <- Pagoda2$new(corrected_cms[[n]], modelType='plain', trim=5, n.cores=5)
  # rs[[n]]$adjustVariance(plot=F, do.par=F, gam.k=10)
}

norm_cms <- lapply(rs, function(r) t(r$counts))
```

## Target correlations
```{r}
correlations_info <- lapply(real_clusters, TargetClusterCorrelation, clusters, corrected_cms, 
                            correction.threshold=0.2, expression.frac.threshold=0.5)
correlations <- lapply(correlations_info, `[[`, 'correlations')
correlations <- bind_rows(correlations) %>% arrange(Correction, Barcode1, Barcode2)
correlations <- correlations %>% arrange(Correction, Barcode1, Barcode2)

raw_correlations <- correlations %>% filter(Correction == 'raw') %>% .$Correlation
correlations <- correlations %>% group_by(Correction) %>% mutate(Diff = (Correlation - raw_correlations) / raw_correlations)
```

```{r, fig.width=6, fig.height=7}
plot_df <- correlations %>% filter(Correction != 'raw')
gg1 <- ggplot(plot_df, aes(x=Diff, color=Correction)) + 
  geom_density() +
  xlim(-0.1, 0.15) +
  theme_pdf(legend.pos=c(0, 1))

gg2 <- ggplot(correlations, aes(x=Correlation, color=Correction), guides=F) +
  geom_density() +
  xlim(0.5, 1.0) +
  theme_pdf(legend.pos=c(0, 1))

cowplot::plot_grid(gg1, gg2, nrow=2, align='v')
# ggsave(paste0(kPlotDir, 'correlation_with_umi_probs.pdf'))
```

```{r, fig.width=7, fig.height=7}
gg2 + facet_wrap(~Cluster) + xlim(0, 1)
```

### Analysis
```{r, message=FALSE}
heatmap_dfs <- lapply(corrected_cms, function(cm) as.matrix(cm[correlations_info$`4`$genes, barcodes]) %>% as.data.frame() %>% 
                     `colnames<-`(c('Barcode1', 'Barcode2')) %>% mutate(Barcode1R = rank(Barcode1), Barcode2R = rank(Barcode2)))

heatmap_dfs <- lapply(heatmap_dfs, function(df) data.frame(Barcode1=pmin(df$Barcode1, 12), Barcode2=pmin(df$Barcode2, 12)) %>% 
                        dcast(Barcode1 ~ Barcode2) %>% melt(variable.name='Barcode2', id.vars='Barcode1', value.name='Expression') %>%
                        mutate(Barcode1=as.integer(Barcode1), Barcode2=as.integer(Barcode2)))

for (n in names(heatmap_dfs)) {
  print(ggplot(heatmap_dfs[[n]]) + geom_tile(aes(x=Barcode1, y=Barcode2, fill=Expression)) + 
    scale_x_discrete(expand = c(0, 0)) + scale_y_discrete(expand = c(0, 0)) +
    labs(x='Cell1', y='Cell2', title=n))
}
```


### Target correlations 2
```{r, warning=FALSE}
correlations_info <- lapply(real_clusters, TargetClusterCorrelation, clusters, corrected_cms, 
                            correction.threshold=0.05, expression.total.threshold=10)
correlations <- lapply(correlations_info, `[[`, 'correlations')
correlations <- bind_rows(correlations) %>% arrange(Correction, Barcode1, Barcode2)
correlations <- correlations %>% arrange(Correction, Barcode1, Barcode2)

raw_correlations <- correlations %>% filter(Correction == 'raw') %>% .$Correlation
correlations <- correlations %>% group_by(Correction) %>% mutate(Diff = (Correlation - raw_correlations) / raw_correlations)

lapply(correlations_info, `[[`, 'genes') %>% sapply(length)
head(correlations)
```

```{r, fig.width=6, fig.height=7, message=FALSE, warning=FALSE}
plot_clusters <- lapply(correlations_info, `[[`, 'genes') %>% sapply(length) %>% (function(x) which(x > 80))
plot_df <- correlations %>% filter(Cluster %in% plot_clusters)
gg1 <- ggplot(plot_df %>% filter(Correction != 'raw'), aes(x=Diff, color=Correction)) + 
  geom_density() + xlim(-0.3, 0.3) + theme_pdf(legend.pos=c(1, 1))

gg2 <- ggplot(plot_df, aes(x=Correlation, color=Correction), guides=F) +
  geom_density() +
  xlim(0.0, 0.9) + theme_pdf(legend.pos=c(1, 1))

cowplot::plot_grid(gg1, gg2, nrow=2, align='v')
```

## Variation
```{r}
var_dfs <- lapply(real_clusters, function(cl) 
  ExpressedGenesVariation(norm_cms, clusters, cluster.num=cl, mean.correction.threshold=0.1, 
                          median.expression.threshold=10))

var_df <- var_dfs %>% bind_rows(.id='Cluster') %>% mutate(Cluster = as.integer(Cluster))
plot_df <- var_df %>% group_by(Gene, Correction, Cluster) %>% 
  summarise(Variation = IQR(Expression), VariationRaw = IQR(ExpressionRaw), 
            VariationDiff = Variation - VariationRaw, Mean = mean(Expression, trim=0.1))

ggplot(plot_df) + geom_density(aes(x=VariationDiff, color=Correction)) + 
  xlim(-10, 10) + theme_pdf(legend.pos=c(1, 1))
```

Dependency between mean and variation:
```{r}
ggplot(plot_df, aes(x=Mean, y=Variation, color=Correction)) + 
  geom_point(alpha=0.8, size=1) + 
  geom_smooth(method='lm') +
  scale_x_log10() + scale_y_log10() + theme_pdf(legend.pos=c(1, 0))
```

## Difference between clusters
```{r}
GetOverexpressedGenes <- function(cm.raw, clusters, cluster.num, median.expression.threshold=0) {
  cluster.cm <- cm.raw[, names(clusters)[clusters == cluster.num]]
  cluster.cm <- cluster.cm[Matrix::rowSums(cluster.cm) > 0, ] %>% as.matrix()

  med.expression <- apply(cluster.cm, 1, mean, trim=0.2)
  return(names(med.expression)[med.expression >= median.expression.threshold])
}

overexpressed_genes <- lapply(norm_cms, function(cm) lapply(real_clusters, function(cl) GetOverexpressedGenes(cm, clusters, cl, median.expression.threshold=5)))
overexpressed_genes <- Reduce(union, lapply(overexpressed_genes, function(g) Reduce(union, g)))
length(overexpressed_genes)
```

```{r, fig.height=7, fig.width=8}
expr_mats <- lapply(norm_cms, function(cm) sapply(real_clusters, function(cl) cm[overexpressed_genes, names(clusters)[clusters == cl]] %>% apply(1, mean, trim=0.2)))
clust_row <- hclust(dist(expr_mats$raw))
clust_col <- hclust(dist(t(expr_mats$raw)))

breaks <- c(seq(0, 2.9, length.out=100), 3)
# ENSG00000147403
# ENSG00000156508
# ENSG00000244734
for (n in names(expr_mats)) {
  pheatmap(log10(1 + expr_mats[[n]]), show_rownames=F, breaks=breaks, cluster_cols=clust_col, cluster_rows=clust_row, main=n)
}
```

## Edit distances
```{r}
SampleNoReps <- function(size, ids, probs) {
  umis <- unique(sample(ids, size=size, prob=probs, replace=T))
  while (length(umis) < size) {
    umis <- unique(c(umis, sample(ids, size=size, prob=probs, replace=T)))
  }
  
  return(umis[1:size])
}
```

```{r}
gene_sizes <- seq(2, 500, 10)
probs_by_size <- mclapply(gene_sizes, function(s) sapply(1:100, function(i) 
  SampleNoReps(s, names(umi_probs), umi_probs) %>% 
    stringdist::stringdistmatrix(method='hamming') %>% as.vector()) %>% 
    dropestr::ValueCounts(return_probs=T), mc.cores=20, mc.allow.recursive=F)

probs_by_size[[1]] <- c(`1`=0, probs_by_size[[1]])
```

