---
title: "Comparison of clusters"
output: 
  html_document:
    df_print: kable
    theme: cerulean
    toc: true
    number_sections: true
  html_notebook: default
---

```{r, include=FALSE}
library(dropestr)
library(ggplot2)
library(ggsci)
library(ggpubr)
library(ggrastr)
library(dplyr)
library(Matrix)
library(parallel)
library(pagoda2)
library(reshape2)

source("./Functions/Functions.R")
source("./Functions/PlotFuncs.R")
source("./Functions/VariationAnalysisFuncs.R")

knitr::opts_chunk$set(fig.width=5, fig.height=3, echo=FALSE, warning=FALSE, message=FALSE)

theme_set(theme_base)

kDatasetName <- 'frozen_bmmc_healthy_donor1'
kPlotsDir <- paste0('~/Data/Plots/Paper/Review/UmiErrors/', kDatasetName, '/')
kDatasetPath <- '/d0-mendel/home/viktor_petukhov/Data/10x/frozen_bmmc_healthy_donor1/'
kDataPath <- paste0(kDatasetPath, 'est_01_20_umi_quality/')
kData10xPath <- paste0(kDatasetPath, 'est_11_10_umi_quality/')
# k10xPath <- paste0(kDatasetPath, 'filtered_matrices_mex/hg19/')
```

```{Rcpp}
#include <Rcpp.h>
#include <vector>
#include <string>

// [[Rcpp::export]]
std::vector<int> pairwise_hamming(const std::vector<std::string> &strs) {
  std::vector<int> distances;
  for (int i = 0; i < strs.size(); ++i) {
    for (int j = i + 1; j < strs.size(); ++j) {
      const std::string &str1 = strs[i];
      const std::string &str2 = strs[j];
      if (str1.length() != str2.length())
        Rcpp::stop("Strings must have the same length");
      
      int ed = 0;
      for (int c_id = 0; c_id < str1.length(); ++c_id) {
        if (str1[c_id] != str2[c_id]) {
          ed++;
        }
      }
      distances.push_back(ed);
    }
  }
  
  return distances;
}
```

```{r}
holder <- readRDS(paste0(kDataPath, 'bmmc.rds'))
if (length(holder$reads_per_umi_per_cell$reads_per_umi[[1]][[1]]) != 2) stop("Quality must be provided")

umi_distribution <- GetUmisDistribution(holder$reads_per_umi_per_cell$reads_per_umi)
umi_probs <- umi_distribution / sum(umi_distribution)
collisions_info <- FillCollisionsAdjustmentInfo(umi_probs, max(holder$cm))
length(holder$reads_per_umi_per_cell$reads_per_umi)
```

```{r}
corrected_cms <- list()
max_upg <- sapply(holder$reads_per_umi_per_cell$reads_per_umi, length) %>% max()
max_upg <- collisions_info[max_upg]
correction_info <- PrepareUmiCorrectionInfo(umi_probs, max_upg, verbosity.level=1)

corrected_cms$bayesian <- CorrectUmiSequenceErrors(holder$reads_per_umi_per_cell, method='Bayesian', return='matrix',
                                                   collisions.info=collisions_info, umi.probabilities=umi_probs,
                                                   correction.info=correction_info, verbosity.level=2, mc.cores=30)

corrected_cms$cluster <- CorrectUmiSequenceErrors(holder$reads_per_umi_per_cell, method='Classic', return='matrix',
                                                  collisions.info=collisions_info, umi.probabilities=umi_probs,
                                                  verbosity.level=2, mc.cores=30)

corrected_cms$`cluster-neq` <- CorrectUmiSequenceErrors(holder$reads_per_umi_per_cell, method='Classic', return='matrix',
                                                    mult=1+1e-4, collisions.info=collisions_info, umi.probabilities=umi_probs,
                                                    verbosity.level=2, mc.cores=30)

corrected_cms$directional <- CorrectUmiSequenceErrors(holder$reads_per_umi_per_cell, method='Classic', return='matrix',
                                                  mult=2, collisions.info=collisions_info, umi.probabilities=umi_probs,
                                                  verbosity.level=2, mc.cores=30)

corrected_cms$`no correction` <- holder$cm
corrected_cms$`no correction`@x <- collisions_info[corrected_cms$`no correction`@x]

saveRDS(corrected_cms, paste0(kDataPath, 'cms3.rds'))
```

```{r}
corrected_cms <- readRDS(paste0(kDataPath, 'cms3.rds'))
corrected_cms <- lapply(corrected_cms, function(cm) cm[grep("^[^;]+$", rownames(cm)), ])
names(corrected_cms) <- c('Bayesian', 'cluster', 'cluster-neq', 'directional', 'no correction')
```

```{r}
# common_genes <- intersect(rownames(holder_10x$cm_raw), rownames(corrected_cms$`no correction`))
# corrected_cms$CellRanger <- holder_10x$cm_raw[common_genes, colnames(corrected_cms$`no correction`)]
# corrected_cms <- lapply(corrected_cms, function(cm) cm[common_genes, ])

# corrected_cms$CellRanger@x <- collisions_info[corrected_cms$CellRanger@x]

correction_colors <- c(`CellRanger`="#3b5ddb", Bayesian="#017A5A", cluster="#9B3BB8", `cluster-neq`="#E69F00", directional="#BD5500", `no correction`='#757575')
```

```{r}
PlotCellsNumberLogLog(Matrix::colSums(holder$cm_raw)) + ggplot2::annotation_logticks(sides='b')
```

# Analysis
Create pagoda object for raw data:
```{r, message=FALSE, warning=FALSE}
kClusteringType <- 'infomap'
r <- GetPagoda(corrected_cms$`no correction`, n.cores=25, clustering.type=kClusteringType, embeding.type='tSNE', verbose=F)
clusters <- r$clusters$PCA[[kClusteringType]]

# r_s1 <- GetPagoda(corrected_cms$cluster, n.cores=25, clustering.type=kClusteringType, embeding.type='tSNE', verbose=F)
# clusters <- r_s1$clusters$PCA[[kClusteringType]]
```

```{r}
clusters_annotated <- read.csv(paste0(kData10xPath, 'clusters_annotated.csv'), row.names=1)
clusters_annotated <- clusters_annotated$Type %>% setNames(clusters_annotated$Barcode)
```

```{r}
kMinCellsPerCluster <- 50
# PlotPagodaEmbeding(r_s1, embeding.type='tSNE', clustering.type=kClusteringType, mark.clusters=T, 
#                    show.legend=F, min.cluster.size=kMinCellsPerCluster, size=0.5, alpha=0.5, show.ticks=F, plot.na=T) + 
#   scale_color_hue(l=55)

PlotPagodaEmbeding(r, clusters=clusters_annotated, mark.clusters=T, show.legend=F, size=0.5, alpha=0.5, show.ticks=F, plot.na=T)

PlotPagodaEmbeding(r, clustering.type=kClusteringType, mark.clusters=T, show.legend=F, 
                   min.cluster.size=kMinCellsPerCluster, size=0.5, alpha=0.5, show.ticks=F, plot.na=T) + 
  scale_color_hue(l=55)
```

```{r}
clusters <- r$clusters$PCA$infomap
real_clusters <- which(table(clusters) > kMinCellsPerCluster)
```

```{r}
sink("/dev/null"); rs <- lapply(corrected_cms, Pagoda2$new, modelType='plain', trim=5, n.cores=5, verbose=F); sink()
norm_cms <- lapply(rs, function(r) t(r$counts))
```

## Magnitude of correction
Raw expression:  
```{r, fig.width=7, fig.height=5}
umis_per_gene <- lapply(corrected_cms, function(cm) cm@x) %>% as_tibble() %>% filter(`no correction` > 1)
ggplot(melt(umis_per_gene, id.vars='no correction'), aes(x = `no correction`, y = `no correction` - value, color = variable)) +
  geom_point_rast(size = 1, alpha=0.05) +
  geom_abline(aes(intercept=0, slope=1)) +
  facet_wrap(~variable) +
  scale_x_log10() + scale_y_log10() + annotation_logticks() +
  labs(x = 'Raw expression', y = 'Correction magnitude') +
  theme_pdf(legend.pos = c(0.05, 1)) +
  guides(color = guide_legend(override.aes=list(alpha=1), title='Correction'))
```

Normalized expression:  
```{r, fig.width=8, fig.height=5, message=FALSE, warning=FALSE}
norm_umis_per_gene <- lapply(norm_cms, function(cm) cm@x) %>% as_tibble() %>% filter(`no correction` > 10)
size_supp_fig <- ggplot(melt(norm_umis_per_gene, id.vars='no correction')) +
  geom_point_rast(aes(x = `no correction`, y = 1e-6 + `no correction` - value, color = variable), 
                  size = 0.2, alpha=0.05, dpi=150, width=4, height=2.5) +
  geom_abline(aes(intercept=0, slope=1)) +
  facet_wrap(~variable) +
  scale_x_log10(limits=c(10, 1010), expand=c(0, 0)) + 
  scale_y_log10(limits=c(1e-2, 1000), expand=c(0, 0)) + annotation_logticks(sides='b') +
  scale_color_manual(values=correction_colors) +
  labs(x = 'Normalized expression without correction', y = 'Correction magnitude') +
  theme_pdf(legend.pos = c(1, 0)) +
  theme(strip.text.x=element_blank(), panel.spacing=unit(3, 'pt')) +
  guides(color=guide_legend(override.aes=list(alpha=1.0, size=1.5), title='Correction'))

size_supp_fig
ggsave(paste0(kPlotsDir, 'SuppBmmcCorrectionSize.pdf'), size_supp_fig, width=8, height=5)
```

Figure:
```{r, fig.width=4, fig.height=4}
umis_plot_df <- melt(norm_umis_per_gene, id.vars='no correction', variable.name='Correction') %>% 
  filter(Correction %in% c('Bayesian', 'cluster')) %>% filter(`no correction` > 10)
gg_correction_size <- ggplot(umis_plot_df, aes(x = `no correction`, y = `no correction` - value, color = Correction)) +
  geom_point_rast(aes(alpha=Correction), size = 0.7, width=4, height=4) +
  # geom_point(aes(alpha=Correction), size = 0.7) +
  scale_x_log10(limits=c(10, 1000), expand=c(0, 0)) + 
  scale_y_log10(limits=c(1e-2, 1000), expand=c(0, 0)) + annotation_logticks() +
  scale_alpha_manual(values=c(Bayesian=0.05, cluster=0.02)) +
  labs(x = 'Expression without correction', y = 'Correction magnitude') +
  theme_pdf(legend.pos = c(0.05, 1)) +
  guides(color = guide_legend(override.aes=list(alpha=1))) +
  scale_color_manual(values=correction_colors)
gg_correction_size
```

## Variation
Variation of a single gene expression within fixed cluster (after normalization) is another possible measure. 
It allows us to increase gene filtration thresholds, as now we analyze single genes, but not gene vectors. Here we used
only genes with the correction size > 10% and median normalized expression > 10.  

```{r}
var_dfs <- lapply(real_clusters, function(cl) 
  ExpressedGenesVariation(norm_cms, clusters, cluster.num=cl, mean.correction.threshold=0.1, 
                          median.expression.threshold=10))

var_df <- var_dfs %>% bind_rows(.id='Cluster') %>% mutate(Cluster = as.integer(Cluster))
```

```{r}
plot_df <- var_df %>% group_by(Gene, Correction, Cluster) %>% 
  summarise(Variation = IQR(Expression), VariationRaw = IQR(ExpressionRaw), 
            VariationDiff = Variation - VariationRaw, Mean = mean(Expression, trim=0.1))

# ggplot(plot_df) + geom_density(aes(x=VariationDiff, color=Correction)) + 
#   xlim(-10, 10) + 
#   labs(x='Variation difference after the correction', y='Density') +
#   theme_pdf(legend.pos=c(1, 1))
```

Dependency between mean and variation:  
```{r, fig.width=4, fig.height=4}
gg_variation <- ggplot(plot_df, aes(x=Mean, y=Variation, color=Correction)) + 
  geom_point_rast(size=1, width=4, height=4) + 
  geom_smooth(method='lm') +
  scale_x_log10() + scale_y_log10() + 
  labs(x='Trimmed mean expression', y='Interquartile range') +
  theme_pdf(legend.pos=c(0, 1))

gg_variation
```

```{r, fig.width=4, fig.height=4}
gg_variation <- ggplot(plot_df, aes(x=Mean, y=Variation, color=Correction)) + 
  geom_point_rast(size=1, width=4, height=4) + 
  geom_smooth(method='lm') +
  scale_x_log10() + scale_y_log10() + 
  labs(x='Trimmed mean expression', y='Interquartile range') +
  theme_pdf(legend.pos=c(0, 1))

gg_variation
```

According to this plot, `cluster` and `directional` corrections increase variation coeffitient.

## Edit distances
```{r}
holder_10x <- readRDS(paste0(kData10xPath, 'bmmc.rds'))
```

Comparison of edit distances with the expected distribution, similar to UMI Tools paper.
```{r}
SampleNoReps <- function(size, ids, probs) {
  umis <- unique(sample(ids, size=size, prob=probs, replace=T))
  while (length(umis) < size) {
    umis <- unique(c(umis, sample(ids, size=size, prob=probs, replace=T)))
  }
  
  return(umis[1:size])
}

ed_probs <- sapply(1:500, function(i) SampleNoReps(1000, names(umi_probs), umi_probs) %>% pairwise_hamming()) %>% 
  dropestr::ValueCounts(return_probs=T)
ed_probs <- ed_probs[paste0(1:5)]
```

```{r}
corrected_reads <- list()
corrected_reads$Bayesian <- CorrectUmiSequenceErrors(holder$reads_per_umi_per_cell, method='Bayesian', return='reads',
                                                   collisions.info=collisions_info, umi.probabilities=umi_probs,
                                                   verbosity.level=2, mc.cores=30)

corrected_reads$cluster <- CorrectUmiSequenceErrors(holder$reads_per_umi_per_cell, method='Classic', return='reads',
                                                  collisions.info=collisions_info, umi.probabilities=umi_probs,
                                                  verbosity.level=2, mc.cores=30)

corrected_reads$`cluster-neq` <- CorrectUmiSequenceErrors(holder$reads_per_umi_per_cell, method='Classic', return='reads',
                                                    mult=1+1e-4, collisions.info=collisions_info, umi.probabilities=umi_probs,
                                                    verbosity.level=2, mc.cores=30)

corrected_reads$directional <- CorrectUmiSequenceErrors(holder$reads_per_umi_per_cell, method='Classic', return='reads',
                                                  mult=2, collisions.info=collisions_info, umi.probabilities=umi_probs,
                                                  verbosity.level=2, mc.cores=30)

corrected_reads$`no correction` <- holder$reads_per_umi_per_cell$reads_per_umi

corrected_reads$CellRanger <- holder_10x$reads_per_umi_per_cell$reads_per_umi

umis_per_gene <- mclapply(corrected_reads, lapply, names, mc.cores=6)
saveRDS(corrected_reads, paste0(kDataPath, 'corrected_rpus2.rds'))
saveRDS(umis_per_gene, paste0(kDataPath, 'corrected_umis_per_gene2.rds'))
```

```{r}
umis_per_gene <- readRDS(paste0(kDataPath, 'corrected_umis_per_gene2.rds'))
```

```{r}
obs_eds <- mclapply(umis_per_gene, function(reads) 
  mclapply(reads, pairwise_hamming, mc.cores=8) %>% unlist(), mc.cores=6)

obs_ed_probs <- mclapply(obs_eds, dropestr::ValueCounts, return_probs=T, mc.cores=6) %>%
  lapply(`[`, paste0(1:5)) %>% lapply(function(x) {x[is.na(x)] <- 0; setNames(x, paste0(1:5))}) %>% 
  as_tibble()

obs_ed_sds <- mclapply(obs_eds, function(x) sd(x) / (length(x) %>% sqrt()), mc.cores=6) %>% unlist()
```

Here, confidence intervals are negligable and not shown:
```{r, fig.width=8, fig.height=8}
levels_order <- c('Bayesian', 'CellRanger', 'cluster', 'cluster-neq', 'directional', 'no correction')

plot_df <- (abs(obs_ed_probs - ed_probs) / ed_probs) %>% mutate(EditDistance=1:5) %>% 
  melt(variable.name = 'Correction', value.name = 'Error', id.vars = 'EditDistance')
plot_df$Correction <- factor(as.character(plot_df$Correction), levels=levels_order, ordered=T)

text_df <- data.frame(Prob=ed_probs, EditDistance=1:5, x=1:5 - 0.03) %>%
  mutate(y = plot_df %>% group_by(EditDistance) %>% summarise(Error=max(Error)) %>% .$Error * 100 + 3.5)

breaks <- seq(0, 100, by=25)
gg_eds <- ggplot(plot_df) + 
  geom_bar(aes(x = EditDistance, y = 100 * Error, fill = Correction), color = 'black', position = 'dodge', stat = 'identity') + 
  labs(x = 'Edit distance', y = 'Relative probability error, %') +
  geom_text(aes(x=x, y=y, label=format(Prob, digits=2)), text_df) +
  scale_y_continuous(expand=c(0.0, 0), limits=c(0, 107), minor_breaks=breaks - 1e-3, breaks=breaks) +
  scale_x_continuous(minor_breaks=NULL) +
  scale_fill_manual(values=correction_colors) +
  theme_pdf(legend.pos=c(1, 1)) +
  theme(panel.grid.major=element_blank())

# gg_upper <- cowplot::plot_grid(gg_variation + annotation_logticks() + rremove("legend"), gg_eds, 
#                                gg_correction_size + rremove('legend'), nrow=2, ncol=2, labels="AUTO")
gg_upper <- cowplot::plot_grid(gg_variation + annotation_logticks() + rremove("legend"), gg_eds, ncol=2, labels="AUTO")
gg_lower <- cowplot::plot_grid(gg_correction_size + rremove('legend'), labels='C')
(gg_fig <- cowplot::plot_grid(gg_upper, gg_lower, nrow=2, align='v'))
# ggsave(paste0(kPlotsDir, 'figure_correction.pdf'), plot=gg_fig, width=8, height=8)
```

No variation:
```{r, fig.width=4, fig.height=8}
gg_fig <- cowplot::plot_grid(gg_eds, gg_correction_size + rremove('legend'), nrow=2, align='v', labels=c('D', 'E'))
gg_fig

saveRDS(list(gg_fig=gg_fig, gg_eds=gg_eds, gg_correction_size=gg_correction_size, umis_plot_df=umis_plot_df,
             plot_df=plot_df, text_df=text_df, correction_colors=correction_colors, levels_order=levels_order), 
        '~/tmp_r_exchange/bmmc_umi_fig_part2.rds')
```

