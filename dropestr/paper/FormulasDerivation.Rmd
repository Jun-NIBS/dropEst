---
title: "Formulas derivation"
output:
  html_document:
    df_print: kable
    number_sections: yes
    theme: cerulean
    toc: yes
  html_notebook: default
---

# Initialization
```{r}
source("./Functions/PlotFuncs.R")

FilterNUmis <- function(reads.per.umi) {
  return(lapply(reads.per.umi, function(rpus) rpus[grep("^[^N]+$", names(rpus))]))
}
```

```{r global_options, include=FALSE}
library(ggplot2)
library(ggsci)
library(ggpubr)
library(dplyr)
library(parallel)

knitr::opts_chunk$set(fig.width=5, fig.height=3, echo=FALSE, warning=FALSE, message=FALSE)

theme_set(theme_bw(base_size=14, base_family='Helvetica') + theme(plot.title = element_text(hjust = 0.5)))
```

```{r}
holder <- readRDS('/d0-mendel/home/viktor_petukhov/Data/10x/aml035_post_transplant/est_10_20_umi_quality/aml035ost_transplant.rds')
reads_per_umi_per_cell <- holder$reads_per_umi_per_cell
reads_per_umi_per_cell$reads_per_umi <- FilterNUmis(holder$reads_per_umi_per_cell$reads_per_umi)
# reads_per_umi_per_cell$reads_per_umi <- holder$reads_per_umi_per_cell$reads_per_umi[1:100000]
# saveRDS(reads_per_umi_per_cell, '/d0-mendel/home/viktor_petukhov/Data/10x/aml035_post_transplant/est_10_20_umi_quality/reads_per_umi_subset.rds')
```

```{r}
reads_per_umi_per_cell <- readRDS('/d0-mendel/home/viktor_petukhov/Data/10x/aml035_post_transplant/est_10_20_umi_quality/reads_per_umi_subset.rds')
```

<!-- Simple filtration of the raw data -->
```{r}
trimmed <- TrimAndCorrect(reads_per_umi_per_cell, umi.trim.length=6, collisions.adj.step=30, mc.cores.large=20, mc.cores.small=20, verbosity.level=2, prepare.only=T)
```

# Formulas derivation

Distribution of reads per UMI depends on the number of UMI per gene:
```{r}
reads_per_umi_trimmed <- ExtractReadsPerUmi(trimmed$reads.per.umi.per.cb)
umis_per_gene_trimmed <- sapply(reads_per_umi_trimmed, length)

PlotReadsDistribution <- function(reads.per.gene, umis.per.gene, min.umis=NULL, max.umis=NULL) {
  if (is.null(min.umis)) {
    min.umis <- 1
  }
  
  if (is.null(max.umis)) {
    max.umis <- max(umis.per.gene)
  }
  
  rpus.filt <- unlist(reads.per.gene[(umis.per.gene >= min.umis) & (umis.per.gene <= max.umis)])
  ggplot() + geom_histogram(aes(x=rpus.filt, y=..count.. / sum(..count..)), bins=50) + 
    xlim(0, 20) + labs(title=paste0("Min: ", min.umis, ", max: ", max.umis), x='Reads per UMI', y='UMI probability')
}

PlotReadsDistribution(reads_per_umi_trimmed, umis_per_gene_trimmed)
PlotReadsDistribution(reads_per_umi_trimmed, umis_per_gene_trimmed, 1, 10)
PlotReadsDistribution(reads_per_umi_trimmed, umis_per_gene_trimmed, 10, 20)
PlotReadsDistribution(reads_per_umi_trimmed, umis_per_gene_trimmed, 20, 50)
PlotReadsDistribution(reads_per_umi_trimmed, umis_per_gene_trimmed, 50, 80)
PlotReadsDistribution(reads_per_umi_trimmed, umis_per_gene_trimmed, 80, 100)
PlotReadsDistribution(reads_per_umi_trimmed, umis_per_gene_trimmed, 100, 200)
PlotReadsDistribution(reads_per_umi_trimmed, umis_per_gene_trimmed, 200, 500)
PlotReadsDistribution(reads_per_umi_trimmed, umis_per_gene_trimmed, 500, 1000)
PlotReadsDistribution(reads_per_umi_trimmed, umis_per_gene_trimmed, 1000)
```

We can quantize number of gene to approximate this dependency:
```{r}
clf <- TrainNBClassifier(trimmed$reads.per.umi.per.cb, 10, gene.size.quants.num=5)

plot_labs <- labs(x='Reads per UMI', y='UMI probability')
for (name in names(clf$Common$RpuProbsByGeneSize)) {
  distr <- clf$Common$RpuProbsByGeneSize[[name]]
  print(ggplot() + geom_bar(aes(x=1:length(distr), y=distr), stat='identity') + xlim(0, 20) + plot_labs + ggtitle(paste0('Quant ', name)))
}

ggplot() + geom_bar(aes(x=1:length(clf$Common$RpuProbs), y=clf$Common$RpuProbs), stat='identity') + 
  xlim(0, 20) + plot_labs + ggtitle('Prior distribution')
```

## Dependency of the error probability on gene size
We can estimate mean number of adjacent UMIs for each gene size using dynamic programming matrices:
```{r}
estimated_nn <- lapply(trimmed$correction.info$dp.matrices, function(m) colSums(m * 0:(nrow(m) - 1)))
estimated_nn <- estimated_nn[trimmed$correction.info$neighb.prob.index[names(trimmed$umi.probabilities)]] %>% bind_cols()
estimated_nn <- apply(estimated_nn, 1, `*`, trimmed$umi.probabilities)
estimated_nn <- colSums(estimated_nn)
```

Let's calculate mean number of adjacent UMIs in the real data:
```{r}
rpus_filt <- reads_per_umi_trimmed[umis_per_gene_trimmed > 1]
upg_filt <- umis_per_gene_trimmed[umis_per_gene_trimmed > 1]

neighbours_num <- sapply(rpus_filt, function(rpu) mean(GetAdjacentUmisNum(rpu, rpu, trimmed$correction.info$neighbours.per.umi, total=T, larger=F, smaller=F)$Total, trim=0.2))

mean_neighbours_num <- sapply(split(neighbours_num, upg_filt), mean)
umis_per_gene_uniq <- as.integer(names(mean_neighbours_num))

rm(upg_filt, rpus_filt)

qplot(x=1:length(estimated_nn), y=estimated_nn, geom='line', color='Estimated') + 
  geom_point(aes(x=umis_per_gene_uniq, y=mean_neighbours_num, color='Observed'), size=0.5) + 
  labs(x='#UMIs per gene', y='Mean #adjacent UMIs') + scale_color_npg(name='') + scale_x_log10()
```

Current estimation uses adjusted number of UMIs, while observed number isn't adjusted. Let's remove adjustment for the estimated number:
```{r}
adjusted_umis_per_gene <- 2:length(estimated_nn)
unadjusted_umis_per_gene <- sapply(adjusted_umis_per_gene, AdjustGeneExpression, trimmed$collisions.info$observed, trimmed$collisions.info$adjusted)

estimated_nn_distinct <- sapply(split(estimated_nn[adjusted_umis_per_gene], unadjusted_umis_per_gene), mean)
unadjusted_umis_per_gene <- unique(unadjusted_umis_per_gene)

rm(adjusted_umis_per_gene)

qplot(x=unadjusted_umis_per_gene, y=estimated_nn_distinct, geom='line', color='Estimated') + 
  geom_point(aes(x=umis_per_gene_uniq, y=mean_neighbours_num, color='Observed'), size=0.5) + 
  labs(x='#UMIs per gene', y='Mean #adjacent UMIs') + scale_color_npg(name='') + scale_x_log10()

qplot(x=unadjusted_umis_per_gene, y=estimated_nn_distinct / (unadjusted_umis_per_gene - 1), geom='line', color='Estimated') + 
  geom_point(aes(x=umis_per_gene_uniq, y=mean_neighbours_num / (umis_per_gene_uniq - 1), color='Observed'), size=0.5) + 
  labs(x='#UMIs per gene', y='Probability of a pair of adjacent UMIs') + scale_color_npg(name='') +
  scale_x_log10() + scale_y_log10()
```

Now we can estimate dependency of error probability on gene size. We can assume that the pure error probability is independent of gene size, but for large genes erroneous UMIs can have the same sequence as one of the real UMIs. In this case, erroneous UMIs won't be observed and can be ignored.
```{r}
err_nn_est <- 0.46
max_nn <- 6 * 3

err_nn_obs_est <- err_nn_est * (max_nn - estimated_nn_distinct) / max_nn
est_nn_with_errors <- err_nn_obs_est + estimated_nn_distinct

qplot(x=distinct_umis_per_gene, y=est_nn_with_errors / (distinct_umis_per_gene - 1), geom='line', color='Estimated') + 
  geom_point(aes(x=umis_per_gene_uniq, y=mean_neighbours_num / (umis_per_gene_uniq - 1), color='Observed'), size=0.5) + 
  labs(x='#UMIs per gene', y='Probability of a pair of adjacent UMIs') + scale_color_npg(name='') +
  scale_x_log10() + scale_y_log10()
```

This model uses a wrong assumtion about uniform distribution of UMIs when estimating expected number of erroneous adjacent UMIs.
